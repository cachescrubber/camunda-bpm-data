{
  "reference": {
    "path": "wiki/user-guide",
    "baseUrl": "https://www.holunda.io/camunda-bpm-data",
    "fileName": "motivation",
    "extension": "html",
    "usePrettyUrl": true,
    "link": "https://www.holunda.io/camunda-bpm-data/wiki/user-guide/motivation"
  },
  "next": {
    "path": "wiki/user-guide",
    "baseUrl": "https://www.holunda.io/camunda-bpm-data",
    "fileName": "features",
    "extension": "html",
    "usePrettyUrl": true,
    "link": "https://www.holunda.io/camunda-bpm-data/wiki/user-guide/features"
  },
  "data": {"title": "Motivation"},
  "description": "",
  "title": "Motivation",
  "content": "<h2 id=\"motivation\"><a href=\"#motivation\" id=\"motivation\" class=\"anchor\"><\/a>Motivation<\/h2>\n<h3 id=\"typed-access-to-process-variables\"><a href=\"#typed-access-to-process-variables\" id=\"typed-access-to-process-variables\" class=\"anchor\"><\/a>Typed access to process variables<\/h3>\n<p>Camunda BPM engine provide Java API to access the process variables.\nThis consists of:<\/p>\n<ul>\n<li><code>RuntimeService<\/code> methods<\/li>\n<li><code>TaskService<\/code> methods<\/li>\n<li>Methods on <code>DelegateExecution<\/code><\/li>\n<li>Methods on <code>DelegateTask<\/code><\/li>\n<li><code>VariableMap<\/code><\/li>\n<\/ul>\n<p>All those methods requires the user of the API to know the variable type.\nHere is a usage example:<\/p>\n<pre><code class=\"language-java\">ProcessInstance processInstance = ...;\nList&lt;OrderPosition&gt; orderPositions = (List&lt;OrderPosition&gt;) runtimeService\n  .getVariable(processInstance.id, &quot;orderPositions&quot;);\n<\/code><\/pre>\n<p>This leads to problems during refactoring and makes variable access more complicated than it is. This library addresses\nthis issue and allows for more convenient type-safe process variable access.<\/p>\n<p>More details can be found in:<\/p>\n<ul>\n<li><a href=\"https://medium.com/holisticon-consultants/data-in-process-part-1-2620bf9abd76\">Data in Process (Part 1)<\/a><\/li>\n<li><a href=\"https://medium.com/holisticon-consultants/data-in-process-part-2-7c6a109e6ee2\">Data in Process (Part 2)<\/a><\/li>\n<\/ul>\n<h3 id=\"variable-guards\"><a href=\"#variable-guards\" id=\"variable-guards\" class=\"anchor\"><\/a>Variable guards<\/h3>\n<p>Process automation often follows strict rules defined by the business. On the other hand, the process execution itself\ndefines rules in terms of pre- and post-conditions on the process payload (stored as process variables in Camunda BPM).\nRising complexity of the implemented processes makes the compliance to those rules challenging. In order to fulfill the\nconditions on process variables during the execution of business processes, a concept of <code>VariableGuard<\/code> is provided by\nthe library. A guard consists of a set of <code>VariableConditions<\/code> and can be evaluated in all contexts, the variables\nare used in: <code>DelegateTask<\/code>, <code>DelegateExecution<\/code>, <code>TaskService<\/code>, <code>RuntimeService<\/code>, <code>VariableMap<\/code>.<\/p>\n<p>Here is an example of a task listener verifying that a process variable <code>ORDER_APPROVED<\/code> is set, which\nwill throw a <code>GuardViolationException<\/code> if the condition is not met.<\/p>\n<pre><code class=\"language-java\">\nimport static io.holunda.camunda.bpm.data.guard.CamundaBpmDataGuards.exists;\n\n@Component\nclass MyGuardListener extends DefaultGuardTaskListener {\n\n    public MyGuardListener() {\n        super(newArrayList(exists(ORDER_APPROVED)), true);\n    }\n}\n<\/code><\/pre>\n<h3 id=\"anti-corruption-layer\"><a href=\"#anti-corruption-layer\" id=\"anti-corruption-layer\" class=\"anchor\"><\/a>Anti-Corruption-Layer<\/h3>\n<p>If a process is signalled or hit by a correlated message, there is no way to check if the transported variables are set correctly.\nIn addition, the variables are written directly to the execution of the correlated process instance. In case of a multi-instance\nevent-base sub-process this will eventually overwrite the values of the main execution.<\/p>\n<p>To prevent all this, a feature called Anti-Corruption-Layer (ACL) is implemented. An ACL is there to protect the execution\nfrom bad modifications and influence the way, the modification is executed. For the protection, an ACL relies on a Variables Guards,\ndefining conditions to be satisfied. For the influencing of modification, the <code>VariableMapTransformer<\/code> can be used.<\/p>\n<p>To use the ACL layer you will need to change the way you correlate messages (or signal the execution). Instead of supplying the variables\ndirectly to the <code>correlate<\/code> method of the <code>RuntimeService<\/code>, the client is wrapping all variables into a map hold by a single transient variable\nand correlate this variable with the process (we call this procedure variable wrapping). On the process side, an execution listener placed\non the end of the catch event is responsible to extract the variable map from the transient variable, check it by passing through the <code>VariablesGuard<\/code>\nand finally pass over to the <code>VariableMapTransformer<\/code> to map from external to internal representation.<\/p>\n<p>Here is the code, required on the client side to correlate the message.<\/p>\n<pre><code class=\"language-java\">@Component\nclass SomeService {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        &quot;__transient&quot;, // name of the transient variable for wrapping\n        true, // if passes the guard, write to local scope\n        new VariablesGuard(exists(ORDER_ID)), // guard defining condition on ORDER_ID\n        IdentityVariableMapTransformer.INSTANCE // use 1:1 transformer\n                                                // write the variables without modifications\n    );\n\n    public void correlate() {\n        VariableMap variables = CamundaBpmData.builder()\n          .set(ORDER_ID, &quot;4711&quot;)\n          .set(ORDER_APPROVED, false)\n          .build();\n        runtimeService.correlateMessage(&quot;message_1&quot;, MESSAGE_ACL.checkAndWrap(variables));\n    }\n}\n<\/code><\/pre>\n<p>On the process side, the BPMN message catch event should have an <code>End<\/code> listener responsible for unwrapping the values. If the listener is\nimplemented as a Spring Bean bounded via delegate expression <code>${messageAclListener}<\/code> then the following code is responsible for providing such a listener:<\/p>\n<pre><code class=\"language-java\">@Configuration\nclass SomeConfiguration {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        &quot;__transient&quot;, // name of the transient variable for wrapping\n        true, // if passes the guard, write to local scope\n        new VariablesGuard(exists(ORDER_ID)), // guard defining condition on ORDER_ID\n        IdentityVariableMapTransformer.INSTANCE // use 1:1 transformer\n                                                // write the variables without modifications\n    );\n\n    @Bean(&quot;messageAclListener&quot;)\n    public ExecutionListener messageAclListener() {\n        return MY_ACL.getExecutionListener();\n    }\n}\n<\/code><\/pre>\n<p>Such a setup will only allow to correlate messages, if the variables provided include a value for the <code>ORDER_ID<\/code>. It will write all\nvariables provided (<code>ORDER_ID<\/code> and <code>ORDER_APPROVED<\/code>) into a local scope of the execution.<\/p>\n"
}