{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Why should I use this? # If you are a software engineer and run process automation projects in your company or on behalf of the customer based on Camunda Process Engine, you probably are familiar with process variables. Camunda offers an API to access them and thereby manipulate the state of the process execution - one of the core features during process automation. Unfortunately, as a user of the Camunda API, you have to exactly know the variable type (so the Java class behind it). For example, if you store a String in a variable \"orderId\" you must extract it as a String in every piece of code. Since there is no code connection between the different code parts, but the BPMN process model orchestrates these snippets to a single process execution, it makes refactoring and testing of process automation projects error-prone and challenging. This library helps you to overcome these difficulties and make access, manipulation and testing process variables really easy and convenient. We leverage the Camunda API and offer you not only a better API but also some additional features . How to start? # A good starting point is the Quick Start . For more detailed documentation, please have a look at User Guide . Get in touch # If you are missing a feature, have a question regarding usage or deployment, you should definitely get in touch with the us. There are various ways to do so: Slack Github Issues Developer Guide","title":"Home"},{"location":"index.html#why-should-i-use-this","text":"If you are a software engineer and run process automation projects in your company or on behalf of the customer based on Camunda Process Engine, you probably are familiar with process variables. Camunda offers an API to access them and thereby manipulate the state of the process execution - one of the core features during process automation. Unfortunately, as a user of the Camunda API, you have to exactly know the variable type (so the Java class behind it). For example, if you store a String in a variable \"orderId\" you must extract it as a String in every piece of code. Since there is no code connection between the different code parts, but the BPMN process model orchestrates these snippets to a single process execution, it makes refactoring and testing of process automation projects error-prone and challenging. This library helps you to overcome these difficulties and make access, manipulation and testing process variables really easy and convenient. We leverage the Camunda API and offer you not only a better API but also some additional features .","title":"Why should I use this?"},{"location":"index.html#how-to-start","text":"A good starting point is the Quick Start . For more detailed documentation, please have a look at User Guide .","title":"How to start?"},{"location":"index.html#get-in-touch","text":"If you are missing a feature, have a question regarding usage or deployment, you should definitely get in touch with the us. There are various ways to do so: Slack Github Issues Developer Guide","title":"Get in touch"},{"location":"quick-start.html","text":"Add dependency # Current version available in Sonatype OSS Maven Central is: In Apache Maven add to your pom.xml : <dependency> <groupId> io.holunda.data </groupId> <artifactId> camunda-bpm-data </artifactId> <version> ${camunda-bpm-data.version} </version> </dependency> For Gradle Kotlin DSL add to your build.gradle.kts : implementation ( \"io.holunda.data:camunda-bpm-data: ${ camunda - bpm - data . version } \" ) For Gradle Groovy DSL add to your build.gradle : implementation 'io.holunda.data:camunda-bpm-data:${camunda-bpm-data.version}' Declare process variable factories # First you have to define your process variables, by providing the variable name and type. For providing the type, different convenience methods exist: Here is an example in Java: import io.holunda.camunda.bpm.data.factory.VariableFactory ; import static io.holunda.camunda.bpm.data.CamundaBpmData.* ; public class OrderApproval { public static final VariableFactory < String > ORDER_ID = stringVariable ( \"orderId\" ); public static final VariableFactory < Order > ORDER = customVariable ( \"order\" , Order . class ); public static final VariableFactory < Boolean > ORDER_APPROVED = booleanVariable ( \"orderApproved\" ); public static final VariableFactory < OrderPosition > ORDER_POSITION = customVariable ( \"orderPosition\" , OrderPosition . class ); public static final VariableFactory < BigDecimal > ORDER_TOTAL = customVariable ( \"orderTotal\" , BigDecimal . class ); } Access process variables from Java Delegate # If you want to access the process variable, call methods on the ProcessVariableFactory to configure the usage context, and then invoke the variable access methods. Here is an example, how it looks like to access variable from JavaDelegate implemented in Java. In this example, the total amount is calculated from the amounts of order positions and stored in the process variable. @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = ORDER_POSITION . from ( execution ). get (); BigDecimal oldTotal = ORDER_TOTAL . from ( execution ). getOptional (). orElse ( BigDecimal . ZERO ); BigDecimal newTotal = oldTotal . add ( orderPosition . getNetCost (). multiply ( BigDecimal . valueOf ( orderPosition . getAmount ()))); ORDER_TOTAL . on ( execution ). setLocal ( newTotal ); }; } } Variable access from REST Controller # Now imagine you are implementing a REST controller for a user task form which loads data from the process application, displays it, captures some input and sends that back to the process application to complete the user task. By doing so, you will usually need to access process variables. Here is an example: @RestController @RequestMapping ( \"/task/approve-order\" ) public class ApproveOrderTaskController { private final TaskService taskService ; public ApproveOrderTaskController ( TaskService taskService ) { this . taskService = taskService ; } @GetMapping ( \"/{taskId}\" ) public ResponseEntity < ApproveTaskDto > loadTask ( @PathVariable ( \"taskId\" ) String taskId ) { Order order = ORDER . from ( taskService , taskId ). get (); return ResponseEntity . ok ( new ApproveTaskDto ( order )); } @PostMapping ( \"/{taskId}\" ) public ResponseEntity < Void > completeTask ( @PathVariable ( \"taskId\" ) String taskId , @RequestBody ApproveTaskCompleteDto userInput ) { VariableMap vars = builder () . set ( ORDER_APPROVED , userInput . getApproved ()) . build (); taskService . complete ( taskId , vars ); return ResponseEntity . noContent (). build (); } } Testing correct variable access # If you want to write the test for the REST controller, you will need to stub the task service and verify that the correct variables has been set. To simplify these tests, we created an additional library module camunda-bpm-data-test . Please put the following dependency into your pom.xml : <dependency> <groupId> io.holunda.data </groupId> <artifactId> camunda-bpm-data-test </artifactId> <version> ${camunda-bpm-data.version} </version> <scope> test </scope> </dependency> Now you can use TaskServiceVariableMockBuilder to stub correct behavior of Camunda Task Service and TaskServiceVerifier to verify the correct access to variables easily. Here is the JUnit test of the REST controller above, making use of camunda-bpm-data-test . public class ApproveOrderTaskControllerTest { private static Order order = new Order ( \"ORDER-ID-1\" , new Date (), new ArrayList <> ()); private TaskService taskService = mock ( TaskService . class ); private TaskServiceMockVerifier verifier = taskServiceMockVerifier ( taskService ); private ApproveOrderTaskController controller = new ApproveOrderTaskController ( taskService ); private String taskId ; @Before public void prepareTest () { reset ( taskService ); taskId = UUID . randomUUID (). toString (); } @Test public void testLoadTask () { // given taskServiceVariableMockBuilder ( taskService ). initial ( ORDER , order ). build (); // when ResponseEntity < ApproveTaskDto > responseEntity = controller . loadTask ( taskId ); // then assertThat ( responseEntity . getStatusCode ()). isEqualTo ( HttpStatus . OK ); assertThat ( responseEntity . getBody ()). isEqualTo ( new ApproveTaskDto ( order )); verifier . verifyGet ( ORDER , taskId ); verifier . verifyNoMoreInteractions (); } @Test public void testCompleteTask () { // when ApproveTaskCompleteDto response = new ApproveTaskCompleteDto ( true ); ResponseEntity < Void > responseEntity = controller . completeTask ( taskId , response ); // then assertThat ( responseEntity . getStatusCode ()). isEqualTo ( HttpStatus . NO_CONTENT ); verifier . verifyComplete ( builder (). set ( ORDER_APPROVED , response . getApproved ()). build (), taskId ); verifier . verifyNoMoreInteractions (); } }","title":"Quick Start"},{"location":"quick-start.html#add-dependency","text":"Current version available in Sonatype OSS Maven Central is: In Apache Maven add to your pom.xml : <dependency> <groupId> io.holunda.data </groupId> <artifactId> camunda-bpm-data </artifactId> <version> ${camunda-bpm-data.version} </version> </dependency> For Gradle Kotlin DSL add to your build.gradle.kts : implementation ( \"io.holunda.data:camunda-bpm-data: ${ camunda - bpm - data . version } \" ) For Gradle Groovy DSL add to your build.gradle : implementation 'io.holunda.data:camunda-bpm-data:${camunda-bpm-data.version}'","title":"Add dependency"},{"location":"quick-start.html#declare-process-variable-factories","text":"First you have to define your process variables, by providing the variable name and type. For providing the type, different convenience methods exist: Here is an example in Java: import io.holunda.camunda.bpm.data.factory.VariableFactory ; import static io.holunda.camunda.bpm.data.CamundaBpmData.* ; public class OrderApproval { public static final VariableFactory < String > ORDER_ID = stringVariable ( \"orderId\" ); public static final VariableFactory < Order > ORDER = customVariable ( \"order\" , Order . class ); public static final VariableFactory < Boolean > ORDER_APPROVED = booleanVariable ( \"orderApproved\" ); public static final VariableFactory < OrderPosition > ORDER_POSITION = customVariable ( \"orderPosition\" , OrderPosition . class ); public static final VariableFactory < BigDecimal > ORDER_TOTAL = customVariable ( \"orderTotal\" , BigDecimal . class ); }","title":"Declare process variable factories"},{"location":"quick-start.html#access-process-variables-from-java-delegate","text":"If you want to access the process variable, call methods on the ProcessVariableFactory to configure the usage context, and then invoke the variable access methods. Here is an example, how it looks like to access variable from JavaDelegate implemented in Java. In this example, the total amount is calculated from the amounts of order positions and stored in the process variable. @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = ORDER_POSITION . from ( execution ). get (); BigDecimal oldTotal = ORDER_TOTAL . from ( execution ). getOptional (). orElse ( BigDecimal . ZERO ); BigDecimal newTotal = oldTotal . add ( orderPosition . getNetCost (). multiply ( BigDecimal . valueOf ( orderPosition . getAmount ()))); ORDER_TOTAL . on ( execution ). setLocal ( newTotal ); }; } }","title":"Access process variables from Java Delegate"},{"location":"quick-start.html#variable-access-from-rest-controller","text":"Now imagine you are implementing a REST controller for a user task form which loads data from the process application, displays it, captures some input and sends that back to the process application to complete the user task. By doing so, you will usually need to access process variables. Here is an example: @RestController @RequestMapping ( \"/task/approve-order\" ) public class ApproveOrderTaskController { private final TaskService taskService ; public ApproveOrderTaskController ( TaskService taskService ) { this . taskService = taskService ; } @GetMapping ( \"/{taskId}\" ) public ResponseEntity < ApproveTaskDto > loadTask ( @PathVariable ( \"taskId\" ) String taskId ) { Order order = ORDER . from ( taskService , taskId ). get (); return ResponseEntity . ok ( new ApproveTaskDto ( order )); } @PostMapping ( \"/{taskId}\" ) public ResponseEntity < Void > completeTask ( @PathVariable ( \"taskId\" ) String taskId , @RequestBody ApproveTaskCompleteDto userInput ) { VariableMap vars = builder () . set ( ORDER_APPROVED , userInput . getApproved ()) . build (); taskService . complete ( taskId , vars ); return ResponseEntity . noContent (). build (); } }","title":"Variable access from REST Controller"},{"location":"quick-start.html#testing-correct-variable-access","text":"If you want to write the test for the REST controller, you will need to stub the task service and verify that the correct variables has been set. To simplify these tests, we created an additional library module camunda-bpm-data-test . Please put the following dependency into your pom.xml : <dependency> <groupId> io.holunda.data </groupId> <artifactId> camunda-bpm-data-test </artifactId> <version> ${camunda-bpm-data.version} </version> <scope> test </scope> </dependency> Now you can use TaskServiceVariableMockBuilder to stub correct behavior of Camunda Task Service and TaskServiceVerifier to verify the correct access to variables easily. Here is the JUnit test of the REST controller above, making use of camunda-bpm-data-test . public class ApproveOrderTaskControllerTest { private static Order order = new Order ( \"ORDER-ID-1\" , new Date (), new ArrayList <> ()); private TaskService taskService = mock ( TaskService . class ); private TaskServiceMockVerifier verifier = taskServiceMockVerifier ( taskService ); private ApproveOrderTaskController controller = new ApproveOrderTaskController ( taskService ); private String taskId ; @Before public void prepareTest () { reset ( taskService ); taskId = UUID . randomUUID (). toString (); } @Test public void testLoadTask () { // given taskServiceVariableMockBuilder ( taskService ). initial ( ORDER , order ). build (); // when ResponseEntity < ApproveTaskDto > responseEntity = controller . loadTask ( taskId ); // then assertThat ( responseEntity . getStatusCode ()). isEqualTo ( HttpStatus . OK ); assertThat ( responseEntity . getBody ()). isEqualTo ( new ApproveTaskDto ( order )); verifier . verifyGet ( ORDER , taskId ); verifier . verifyNoMoreInteractions (); } @Test public void testCompleteTask () { // when ApproveTaskCompleteDto response = new ApproveTaskCompleteDto ( true ); ResponseEntity < Void > responseEntity = controller . completeTask ( taskId , response ); // then assertThat ( responseEntity . getStatusCode ()). isEqualTo ( HttpStatus . NO_CONTENT ); verifier . verifyComplete ( builder (). set ( ORDER_APPROVED , response . getApproved ()). build (), taskId ); verifier . verifyNoMoreInteractions (); } }","title":"Testing correct variable access"},{"location":"developer-guide/contribution.html","text":"There are several ways in which you may contribute to this project. File new issues if you found a bug or missing feature Submit a pull request, if you have a solution for on of the issues Found a bug or missing feature? # Please file an issue in our issue tracking system. Submit a Pull Request # If you found a solution to an open issue and implemented it, we would be happy to add your contribution in the code base. For doing so, please create a pull request. Prior to that, please make sure you rebased against the develop branch sticked to project coding conventions added test cases for the problem you are solving added docs, describing the change generally complied with codeacy report","title":"Contributing"},{"location":"developer-guide/contribution.html#found-a-bug-or-missing-feature","text":"Please file an issue in our issue tracking system.","title":"Found a bug or missing feature?"},{"location":"developer-guide/contribution.html#submit-a-pull-request","text":"If you found a solution to an open issue and implemented it, we would be happy to add your contribution in the code base. For doing so, please create a pull request. Prior to that, please make sure you rebased against the develop branch sticked to project coding conventions added test cases for the problem you are solving added docs, describing the change generally complied with codeacy report","title":"Submit a Pull Request"},{"location":"developer-guide/project-setup.html","text":"If you are interested in developing and building the project please follow the following instruction. Version control # To check out sources of the project, please execute from your command line: git clone https://github.com/holunda-io/camunda-bpm-data.git cd camunda-bpm-data We are using gitflow in our git SCM. That means that you should start from develop branch, create a feature/<name> out of it and once it is completed create a pull request containing it. Please squash your commits before submitting and use semantic commit messages, if possible. Project Build # Perform the following steps to get a development setup up and running. ./mvnw clean install Integration Tests # The default build command above will NOT run failsafe Maven plugin executing the integration tests (These are JUnit tests with class names ending with ITest). In order to run integration tests, please call from your command line: ./mvnw -Pitest Project build modes and profiles # Camunda Version # You can choose the used Camunda version by specifying the profile camunda-ee or camunda-ce . The default version is a Community Edition. Specify -Pcamunda-ee to switch to Camunda Enterprise edition. This will require a valid Camunda license. You can put it into a file ~/.camunda/license.txt and it will be detected automatically. Examples # If you want to skip the build of examples, please specify the -DskipExamples switch in your command line. Documentation # We are using MkDocs for generation of a static site documentation and rely on markdown as much as possible. To install it, please run once: python3 -m pip install -r ./docs/requirements.txt Note If you want to develop your docs in 'live' mode, run mkdocs serve and access the http://localhost:8000/ from your browser. For creation of documentation locally, please run: mkdocs build Generation of JavaDoc and Sources # By default, the sources and javadoc API documentation are not generated from the source code. To enable this: ./mvnw clean install -Prelease -Dgpg.skip = true Starting example application # To start applications, either use your IDE and create run configuration for the classes: io.holunda.camunda.bpm.data.example.CamundaBpmDataProcessApplication io.holunda.camunda.bpm.data.example.kotlin.CamundaBpmDataKotlinExampleApplication Alternatively, you can run them from the command line: ./mvn spring-boot:run -f example/example-java ./mvn spring-boot:run -f example/example-kotlin Continuous Integration # GitHub Actions is building all branches on commit hook. In addition, a special action is building releases from master branch. Release Management # Release management has been set up for use of Sonatype Nexus (= Maven Central). What modules get deployed to repository # Currently, the following modules are released to OSS Maven Central: camunda-bpm-data-parent camunda-bpm-data camunda-bpm-data-test Trigger new release # Note This operation requires special permissions. We use gitflow for development (see A successful git branching model for more details). You could use gitflow with native git commands, but then you would have to change the versions in the poms manually. Therefor we use the mvn gitflow plugin , which handles this and other things nicely. You can build a release with: ./mvnw gitflow:release-start ./mvnw gitflow:release-finish This will update the versions in the pom.xml s accordingly and push the release tag to the master branch and update the develop branch for the new development version. Create feature for development # You can create a feature branch for development using: ./mvnw gitflow:feature-start Note This operation requires special permissions. After the feature is complete, create a PR. To merge the PR into develop use the command: ./mvnw gitflow:feature-finish Trigger a deploy # Note This operation requires special permissions. Currently, CI allows for deployment of artifacts to Maven Central and is executed via Github Actions. This means, that a push to master branch will start the corresponding build job, and if successful the artifacts will get into Staging Repositories of OSS Sonatype without manual intervention. The repository gets automatically closed and released on successful upload. If you still want to execute the deployment from your local machine, you need to execute the following command on the master branch: ./mvnw clean deploy -B -DskipTests -DskipExamples -Prelease","title":"Project Setup"},{"location":"developer-guide/project-setup.html#version-control","text":"To check out sources of the project, please execute from your command line: git clone https://github.com/holunda-io/camunda-bpm-data.git cd camunda-bpm-data We are using gitflow in our git SCM. That means that you should start from develop branch, create a feature/<name> out of it and once it is completed create a pull request containing it. Please squash your commits before submitting and use semantic commit messages, if possible.","title":"Version control"},{"location":"developer-guide/project-setup.html#project-build","text":"Perform the following steps to get a development setup up and running. ./mvnw clean install","title":"Project Build"},{"location":"developer-guide/project-setup.html#integration-tests","text":"The default build command above will NOT run failsafe Maven plugin executing the integration tests (These are JUnit tests with class names ending with ITest). In order to run integration tests, please call from your command line: ./mvnw -Pitest","title":"Integration Tests"},{"location":"developer-guide/project-setup.html#project-build-modes-and-profiles","text":"","title":"Project build modes and profiles"},{"location":"developer-guide/project-setup.html#camunda-version","text":"You can choose the used Camunda version by specifying the profile camunda-ee or camunda-ce . The default version is a Community Edition. Specify -Pcamunda-ee to switch to Camunda Enterprise edition. This will require a valid Camunda license. You can put it into a file ~/.camunda/license.txt and it will be detected automatically.","title":"Camunda Version"},{"location":"developer-guide/project-setup.html#examples","text":"If you want to skip the build of examples, please specify the -DskipExamples switch in your command line.","title":"Examples"},{"location":"developer-guide/project-setup.html#documentation","text":"We are using MkDocs for generation of a static site documentation and rely on markdown as much as possible. To install it, please run once: python3 -m pip install -r ./docs/requirements.txt Note If you want to develop your docs in 'live' mode, run mkdocs serve and access the http://localhost:8000/ from your browser. For creation of documentation locally, please run: mkdocs build","title":"Documentation"},{"location":"developer-guide/project-setup.html#generation-of-javadoc-and-sources","text":"By default, the sources and javadoc API documentation are not generated from the source code. To enable this: ./mvnw clean install -Prelease -Dgpg.skip = true","title":"Generation of JavaDoc and Sources"},{"location":"developer-guide/project-setup.html#starting-example-application","text":"To start applications, either use your IDE and create run configuration for the classes: io.holunda.camunda.bpm.data.example.CamundaBpmDataProcessApplication io.holunda.camunda.bpm.data.example.kotlin.CamundaBpmDataKotlinExampleApplication Alternatively, you can run them from the command line: ./mvn spring-boot:run -f example/example-java ./mvn spring-boot:run -f example/example-kotlin","title":"Starting example application"},{"location":"developer-guide/project-setup.html#continuous-integration","text":"GitHub Actions is building all branches on commit hook. In addition, a special action is building releases from master branch.","title":"Continuous Integration"},{"location":"developer-guide/project-setup.html#release-management","text":"Release management has been set up for use of Sonatype Nexus (= Maven Central).","title":"Release Management"},{"location":"developer-guide/project-setup.html#what-modules-get-deployed-to-repository","text":"Currently, the following modules are released to OSS Maven Central: camunda-bpm-data-parent camunda-bpm-data camunda-bpm-data-test","title":"What modules get deployed to repository"},{"location":"developer-guide/project-setup.html#trigger-new-release","text":"Note This operation requires special permissions. We use gitflow for development (see A successful git branching model for more details). You could use gitflow with native git commands, but then you would have to change the versions in the poms manually. Therefor we use the mvn gitflow plugin , which handles this and other things nicely. You can build a release with: ./mvnw gitflow:release-start ./mvnw gitflow:release-finish This will update the versions in the pom.xml s accordingly and push the release tag to the master branch and update the develop branch for the new development version.","title":"Trigger new release"},{"location":"developer-guide/project-setup.html#create-feature-for-development","text":"You can create a feature branch for development using: ./mvnw gitflow:feature-start Note This operation requires special permissions. After the feature is complete, create a PR. To merge the PR into develop use the command: ./mvnw gitflow:feature-finish","title":"Create feature for development"},{"location":"developer-guide/project-setup.html#trigger-a-deploy","text":"Note This operation requires special permissions. Currently, CI allows for deployment of artifacts to Maven Central and is executed via Github Actions. This means, that a push to master branch will start the corresponding build job, and if successful the artifacts will get into Staging Repositories of OSS Sonatype without manual intervention. The repository gets automatically closed and released on successful upload. If you still want to execute the deployment from your local machine, you need to execute the following command on the master branch: ./mvnw clean deploy -B -DskipTests -DskipExamples -Prelease","title":"Trigger a deploy"},{"location":"user-guide/examples-java.html","text":"The following example code demonstrates the usage of the library using Java. Define variable # public class OrderApproval { public static final VariableFactory < String > ORDER_ID = stringVariable ( \"orderId\" ); public static final VariableFactory < Order > ORDER = customVariable ( \"order\" , Order . class ); public static final VariableFactory < Boolean > ORDER_APPROVED = booleanVariable ( \"orderApproved\" ); public static final VariableFactory < OrderPosition > ORDER_POSITION = customVariable ( \"orderPosition\" , OrderPosition . class ); public static final VariableFactory < BigDecimal > ORDER_TOTAL = customVariable ( \"orderTotal\" , BigDecimal . class ); } Read variable from Java delegate # @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = ORDER_POSITION . from ( execution ). get (); Boolean orderApproved = ORDER_APPROVED . from ( execution ). getLocal (); Optional < BigDecimal > orderTotal = ORDER_TOTAL . from ( execution ). getOptional (); }; } } Write variable from Java delegate # import java.math.BigDecimal ; @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = new OrderPosition ( \"Pencil\" , BigDecimal . valueOf ( 1.5 ), 1 ); ORDER_POSITION . on ( execution ). set ( orderPosition ); }; } } Remove variable from Java delegate # import java.math.BigDecimal ; @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { ORDER_APPROVED . on ( execution ). removeLocal (); }; } } Update variable from Java delegate # import java.math.BigDecimal ; @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = ORDER_POSITION . from ( execution ). get (); ORDER_TOTAL . on ( execution ). updateLocal ( amount -> amount . add ( orderPosition . getNetCost (). multiply ( BigDecimal . valueOf ( orderPosition . getAmount ())))); }; } } Fluent API to remove several variables # @Configuration class JavaDelegates { @Bean public ExecutionListener removeProcessVariables () { return execution -> { CamundaBpmData . writer ( execution ) . remove ( ORDER_ID ) . remove ( ORDER ) . remove ( ORDER_APPROVED ) . remove ( ORDER_TOTAL ) . removeLocal ( ORDER_POSITIONS ); }; } } Fluent API to set several variables # @Component class SomeService { @Autowired private RuntimeService runtimeService ; @Autowired private TaskService taskService ; public void setNewValuesForExecution ( String executionId , String orderId , Boolean orderApproved ) { CamundaBpmData . writer ( runtimeService , executionId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ) . update ( ORDER_TOTAL , amount -> amount . add ( 10 )); } public void setNewValuesForTask ( String taskId , String orderId , Boolean orderApproved ) { CamundaBpmData . writer ( taskService , taskId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ); } public void start () { VariableMap variables = CamundaBpmData . writer () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . startProcessInstanceById ( \"myId\" , \"businessKey\" , variables ); } } Fluent API to read several variables # @Component class SomeService { @Autowired private RuntimeService runtimeService ; @Autowired private TaskService taskService ; public String readValuesFromExecution ( String executionId ) { VariableReader reader = CamundaBpmData . reader ( runtimeService , executionId ); String orderId = reader . get ( ORDER_ID ); Boolean orderApproved = reader . get ( ORDER_APPROVED ); if ( orderApproved ) { // ... } return orderId ; } public String readValuesFromTask ( String taskId ) { VariableReader reader = CamundaBpmData . reader ( taskService , taskId ); String orderId = reader . get ( ORDER_ID ); Boolean orderApproved = reader . get ( ORDER_APPROVED ); if ( orderApproved ) { // ... } return orderId ; } } Anti-Corruption-Layer: Wrap variables to correlate # @Component class SomeService { private static final AntiCorruptionLayer MESSAGE_ACL = CamundaBpmDataMapper . identityReplace ( \"__transient\" , true ); public void correlate () { VariableMap variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . wrap ( variables )); } } Anti-Corruption-Layer: Check and wrap variables to correlate # @Component class SomeService { private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , true , new VariablesGuard ( exists ( ORDER_ID )), IdentityVariableMapTransformer . INSTANCE ); public void correlate () { VariableMap variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . checkAndWrap ( variables )); } } Define Guards to validate variables in the process # @Configuration class VariableGuardConfiguration { public static final String MY_GUARD_BEANNAME = \"myGuardBeanName\" ; @Bean public Supplier < Validator > validatorSupplier () { // assuming dependencys to implement javax.validation:validation-api are present return () -> Validation . buildDefaultValidatorFactory (). getValidator (); } @Bean ( VariableGuardConfiguration . MY_GUARD_BEANNAME ) public ExecutionListener myGuardBeanName ( Supplier < Validator > validatorSupplier ) { return new DefaultGuardExecutionListener ( new VariablesGuard ( Arrays . asList ( exists ( REQUIRED_VALUE ), notExists ( FUTURE_VALUE ), hasValue ( THE_ANSWER , 42 ), hasOneOfValues ( MY_DIRECTION , Set . of ( \"left\" , \"up\" , \"down\" )), isEmail ( USER_EMAIL ), isUuid ( DOCUMENT_ID ), matches ( DOCUMENT_BODY , this :: myDocumentBodyMatcher ), matches ( DOCUMENT_BODY , this :: myDocumentBodyMatcher , this :: validationMessageSupplier ), matchesRegex ( DOCUMENT_BODY , \"^Dude.*\" , \"Starts with 'Dude'\" ), isValidBean ( My_DOCUMENT , validatorSupplier ) ) ), true ); } private Boolean myDocumentBodyMatcher ( String body ) { return true ; } private String validationMessageSupplier ( VariableFactory < String > variableFactory , String localLabel , Optional < String > option ) { return String . format ( \"Expecting%s variable '%s' to always match my document body matcher, but its value '%s' has not.\" , localLabel , variableFactory . getName (), option . orElse ( \"\" )); } } class MyDocument { @Email public String email ; } Example project # For more examples, please check out the Java Example project, at GitHub","title":"Usage in Java"},{"location":"user-guide/examples-java.html#define-variable","text":"public class OrderApproval { public static final VariableFactory < String > ORDER_ID = stringVariable ( \"orderId\" ); public static final VariableFactory < Order > ORDER = customVariable ( \"order\" , Order . class ); public static final VariableFactory < Boolean > ORDER_APPROVED = booleanVariable ( \"orderApproved\" ); public static final VariableFactory < OrderPosition > ORDER_POSITION = customVariable ( \"orderPosition\" , OrderPosition . class ); public static final VariableFactory < BigDecimal > ORDER_TOTAL = customVariable ( \"orderTotal\" , BigDecimal . class ); }","title":"Define variable"},{"location":"user-guide/examples-java.html#read-variable-from-java-delegate","text":"@Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = ORDER_POSITION . from ( execution ). get (); Boolean orderApproved = ORDER_APPROVED . from ( execution ). getLocal (); Optional < BigDecimal > orderTotal = ORDER_TOTAL . from ( execution ). getOptional (); }; } }","title":"Read variable from Java delegate"},{"location":"user-guide/examples-java.html#write-variable-from-java-delegate","text":"import java.math.BigDecimal ; @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = new OrderPosition ( \"Pencil\" , BigDecimal . valueOf ( 1.5 ), 1 ); ORDER_POSITION . on ( execution ). set ( orderPosition ); }; } }","title":"Write variable from Java delegate"},{"location":"user-guide/examples-java.html#remove-variable-from-java-delegate","text":"import java.math.BigDecimal ; @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { ORDER_APPROVED . on ( execution ). removeLocal (); }; } }","title":"Remove variable from Java delegate"},{"location":"user-guide/examples-java.html#update-variable-from-java-delegate","text":"import java.math.BigDecimal ; @Configuration class JavaDelegates { @Bean public JavaDelegate calculateOrderPositions () { return execution -> { OrderPosition orderPosition = ORDER_POSITION . from ( execution ). get (); ORDER_TOTAL . on ( execution ). updateLocal ( amount -> amount . add ( orderPosition . getNetCost (). multiply ( BigDecimal . valueOf ( orderPosition . getAmount ())))); }; } }","title":"Update variable from Java delegate"},{"location":"user-guide/examples-java.html#fluent-api-to-remove-several-variables","text":"@Configuration class JavaDelegates { @Bean public ExecutionListener removeProcessVariables () { return execution -> { CamundaBpmData . writer ( execution ) . remove ( ORDER_ID ) . remove ( ORDER ) . remove ( ORDER_APPROVED ) . remove ( ORDER_TOTAL ) . removeLocal ( ORDER_POSITIONS ); }; } }","title":"Fluent API to remove several variables"},{"location":"user-guide/examples-java.html#fluent-api-to-set-several-variables","text":"@Component class SomeService { @Autowired private RuntimeService runtimeService ; @Autowired private TaskService taskService ; public void setNewValuesForExecution ( String executionId , String orderId , Boolean orderApproved ) { CamundaBpmData . writer ( runtimeService , executionId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ) . update ( ORDER_TOTAL , amount -> amount . add ( 10 )); } public void setNewValuesForTask ( String taskId , String orderId , Boolean orderApproved ) { CamundaBpmData . writer ( taskService , taskId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ); } public void start () { VariableMap variables = CamundaBpmData . writer () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . startProcessInstanceById ( \"myId\" , \"businessKey\" , variables ); } }","title":"Fluent API to set several variables"},{"location":"user-guide/examples-java.html#fluent-api-to-read-several-variables","text":"@Component class SomeService { @Autowired private RuntimeService runtimeService ; @Autowired private TaskService taskService ; public String readValuesFromExecution ( String executionId ) { VariableReader reader = CamundaBpmData . reader ( runtimeService , executionId ); String orderId = reader . get ( ORDER_ID ); Boolean orderApproved = reader . get ( ORDER_APPROVED ); if ( orderApproved ) { // ... } return orderId ; } public String readValuesFromTask ( String taskId ) { VariableReader reader = CamundaBpmData . reader ( taskService , taskId ); String orderId = reader . get ( ORDER_ID ); Boolean orderApproved = reader . get ( ORDER_APPROVED ); if ( orderApproved ) { // ... } return orderId ; } }","title":"Fluent API to read several variables"},{"location":"user-guide/examples-java.html#anti-corruption-layer-wrap-variables-to-correlate","text":"@Component class SomeService { private static final AntiCorruptionLayer MESSAGE_ACL = CamundaBpmDataMapper . identityReplace ( \"__transient\" , true ); public void correlate () { VariableMap variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . wrap ( variables )); } }","title":"Anti-Corruption-Layer: Wrap variables to correlate"},{"location":"user-guide/examples-java.html#anti-corruption-layer-check-and-wrap-variables-to-correlate","text":"@Component class SomeService { private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , true , new VariablesGuard ( exists ( ORDER_ID )), IdentityVariableMapTransformer . INSTANCE ); public void correlate () { VariableMap variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . checkAndWrap ( variables )); } }","title":"Anti-Corruption-Layer: Check and wrap variables to correlate"},{"location":"user-guide/examples-java.html#define-guards-to-validate-variables-in-the-process","text":"@Configuration class VariableGuardConfiguration { public static final String MY_GUARD_BEANNAME = \"myGuardBeanName\" ; @Bean public Supplier < Validator > validatorSupplier () { // assuming dependencys to implement javax.validation:validation-api are present return () -> Validation . buildDefaultValidatorFactory (). getValidator (); } @Bean ( VariableGuardConfiguration . MY_GUARD_BEANNAME ) public ExecutionListener myGuardBeanName ( Supplier < Validator > validatorSupplier ) { return new DefaultGuardExecutionListener ( new VariablesGuard ( Arrays . asList ( exists ( REQUIRED_VALUE ), notExists ( FUTURE_VALUE ), hasValue ( THE_ANSWER , 42 ), hasOneOfValues ( MY_DIRECTION , Set . of ( \"left\" , \"up\" , \"down\" )), isEmail ( USER_EMAIL ), isUuid ( DOCUMENT_ID ), matches ( DOCUMENT_BODY , this :: myDocumentBodyMatcher ), matches ( DOCUMENT_BODY , this :: myDocumentBodyMatcher , this :: validationMessageSupplier ), matchesRegex ( DOCUMENT_BODY , \"^Dude.*\" , \"Starts with 'Dude'\" ), isValidBean ( My_DOCUMENT , validatorSupplier ) ) ), true ); } private Boolean myDocumentBodyMatcher ( String body ) { return true ; } private String validationMessageSupplier ( VariableFactory < String > variableFactory , String localLabel , Optional < String > option ) { return String . format ( \"Expecting%s variable '%s' to always match my document body matcher, but its value '%s' has not.\" , localLabel , variableFactory . getName (), option . orElse ( \"\" )); } } class MyDocument { @Email public String email ; }","title":"Define Guards to validate variables in the process"},{"location":"user-guide/examples-java.html#example-project","text":"For more examples, please check out the Java Example project, at GitHub","title":"Example project"},{"location":"user-guide/examples-kotlin.html","text":"The following snippets demonstrate the usage of the library from Kotlin Define variable # import io.holunda.data.CamundaBpmDataKotlin object Variables { val ORDER_ID = stringVariable ( \"orderId\" ) val ORDER : VariableFactory < Order > = customVariable ( \"order\" ) val ORDER_APPROVED = booleanVariable ( \"orderApproved\" ) val ORDER_POSITION : VariableFactory < OrderPosition > = customVariable ( \"orderPosition\" ) val ORDER_TOTAL : VariableFactory < BigDecimal > = customVariable ( \"orderTotal\" ) } Read variable from Java delegate # @Configuration class JavaDelegates { @Bean fun calculateOrderPositions () = JavaDelegate { execution -> val orderPosition = ORDER_POSITION . from ( execution ). get () // order position is of type OrderPosition } } Write variable from Java delegate # import java.math.BigDecimal @Configuration class JavaDelegates { @Bean fun calculateOrderPositions () = JavaDelegate { execution -> val orderPosition = ORDER_POSITION . from ( execution ). get () ORDER_TOTAL . on ( execution ). set { orderPosition . netCost . times ( BigDecimal . valueOf ( orderPosition . amount )) } } } Remove variable from Java delegate # @Configuration class JavaDelegates { @Bean fun removeTotal () = JavaDelegate { execution -> ORDER_TOTAL . on ( execution ). remove () } } Update variable from Java delegate # import java.math.BigDecimal @Configuration class JavaDelegates { @Bean fun calculateOrderPositions () = JavaDelegate { execution -> val orderPosition = ORDER_POSITION . from ( execution ). get () ORDER_TOTAL . on ( execution ). update { it . plus ( orderPosition . netCost . times ( BigDecimal . valueOf ( orderPosition . amount ))) } } } Fluent API to remove several variables # import io.holunda.camunda.bpm.data.remove @Configuration class JavaDelegates { @Bean fun removeProcessVariables () = JavaDelegate { execution -> execution . remove ( ORDER_ID ) . remove ( ORDER ) . remove ( ORDER_APPROVED ) . remove ( ORDER_TOTAL ) . removeLocal ( ORDER_POSITIONS ) } } Fluent API to set several variables # @Component class SomeService ( private val runtimeService : RuntimeService , private val taskService : TaskService ) { fun setNewValuesForExecution ( executionId : String , rderId : String , orderApproved : Boolean ) { runtimeService . writer ( executionId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ) . update ( ORDER_TOTAL , { amount -> amount . add ( 10 ) }) } fun setNewValuesForTask ( taskId : String , orderId : String , orderApproved : Boolean ) { taskService . writer ( taskId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ) } fun start () { val variables = createProcessVariables () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) runtimeService . startProcessInstanceById ( \"myId\" , \"businessKey\" , variables ) } } Fluent API to read several variables # @Component class SomeService ( private val runtimeService : RuntimeService , private val taskService : TaskService ) { fun readValuesFromExecution ( executionId : String ): String { val reader = CamundaBpmData . reader ( runtimeService , executionId ) val orderId = reader . get ( ORDER_ID ) val orderApproved = reader . get ( ORDER_APPROVED ) if ( orderApproved ) { // ... } return orderId } fun readValuesFromTask ( taskId : String ): String { val reader = CamundaBpmData . reader ( taskService , taskId ) val orderId = reader . get ( ORDER_ID ) val orderApproved = reader . get ( ORDER_APPROVED ) if ( orderApproved ) { // ... } return orderId } } Anti-Corruption-Layer: Wrap variables to correlate # @Component class SomeService { val MESSAGE_ACL = CamundaBpmDataMapper . identityReplace ( \"__transient\" , true ); fun correlate () { val variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . wrap ( variables )); } } Anti-Corruption-Layer: Check and wrap variables to correlate # @Component class SomeService { val MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , true , VariablesGuard ( exists ( ORDER_ID )), IdentityVariableMapTransformer ); fun correlate () { val variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . checkAndWrap ( variables )); } } Define Guards to validate variables in the process # @Configuration class VariableGuardConfiguration { companion object { const val LOAD_OPERATIONAL_FILE_GUARD = \"loadOperationalFileGuard\" ; } @Bean // assuming dependencys to implement javax.validation:validation-api are present fun validatorSupplier (): Supplier < Validator > = Supplier { Validation . buildDefaultValidatorFactory (). validator } @Bean ( LOAD_OPERATIONAL_FILE_GUARD ) fun loadOperationalFileGuard ( validatorSupplier : Supplier < Validator > ): ExecutionListener = DefaultGuardExecutionListener ( VariablesGuard ( listOf ( REQUIRED_VALUE . exists (), FUTURE_VALUE . notExists (), THE_ANSWER . hasValue ( 42 ), MY_DIRECTION . hasOneOfValues ( setOf ( \"left\" , \"up\" , \"down\" )), USER_EMAIL . isEmail (), DOCUMENT_ID . isUuid (), DOCUMENT_BODY . matches { return @matches true }, DOCUMENT_BODY . matches ( this :: validationMessageSupplier ) { return @matches true }, DOCUMENT_BODY . matchesRegexLocal ( Regex ( \"^Dude.*\" ), \"Starts with 'Dude'\" ), MY_DOCUMENT . isValidBean ( validatorSupplier ) ) ), true ) private fun validationMessageSupplier ( variableFactory : VariableFactory < String > , localLabel : String , option : Optional < String > ) = \"Expecting $ localLabel variable ' ${ variableFactory . name } ' to always match my document body matcher, but its value ' ${ option . get () } ' has not.\" } class MyDocument ( @field : Email val email : String ) Example project # For more examples, please check out the Kotlin Example project, at GitHub .","title":"Usage in Kotlin"},{"location":"user-guide/examples-kotlin.html#define-variable","text":"import io.holunda.data.CamundaBpmDataKotlin object Variables { val ORDER_ID = stringVariable ( \"orderId\" ) val ORDER : VariableFactory < Order > = customVariable ( \"order\" ) val ORDER_APPROVED = booleanVariable ( \"orderApproved\" ) val ORDER_POSITION : VariableFactory < OrderPosition > = customVariable ( \"orderPosition\" ) val ORDER_TOTAL : VariableFactory < BigDecimal > = customVariable ( \"orderTotal\" ) }","title":"Define variable"},{"location":"user-guide/examples-kotlin.html#read-variable-from-java-delegate","text":"@Configuration class JavaDelegates { @Bean fun calculateOrderPositions () = JavaDelegate { execution -> val orderPosition = ORDER_POSITION . from ( execution ). get () // order position is of type OrderPosition } }","title":"Read variable from Java delegate"},{"location":"user-guide/examples-kotlin.html#write-variable-from-java-delegate","text":"import java.math.BigDecimal @Configuration class JavaDelegates { @Bean fun calculateOrderPositions () = JavaDelegate { execution -> val orderPosition = ORDER_POSITION . from ( execution ). get () ORDER_TOTAL . on ( execution ). set { orderPosition . netCost . times ( BigDecimal . valueOf ( orderPosition . amount )) } } }","title":"Write variable from Java delegate"},{"location":"user-guide/examples-kotlin.html#remove-variable-from-java-delegate","text":"@Configuration class JavaDelegates { @Bean fun removeTotal () = JavaDelegate { execution -> ORDER_TOTAL . on ( execution ). remove () } }","title":"Remove variable from Java delegate"},{"location":"user-guide/examples-kotlin.html#update-variable-from-java-delegate","text":"import java.math.BigDecimal @Configuration class JavaDelegates { @Bean fun calculateOrderPositions () = JavaDelegate { execution -> val orderPosition = ORDER_POSITION . from ( execution ). get () ORDER_TOTAL . on ( execution ). update { it . plus ( orderPosition . netCost . times ( BigDecimal . valueOf ( orderPosition . amount ))) } } }","title":"Update variable from Java delegate"},{"location":"user-guide/examples-kotlin.html#fluent-api-to-remove-several-variables","text":"import io.holunda.camunda.bpm.data.remove @Configuration class JavaDelegates { @Bean fun removeProcessVariables () = JavaDelegate { execution -> execution . remove ( ORDER_ID ) . remove ( ORDER ) . remove ( ORDER_APPROVED ) . remove ( ORDER_TOTAL ) . removeLocal ( ORDER_POSITIONS ) } }","title":"Fluent API to remove several variables"},{"location":"user-guide/examples-kotlin.html#fluent-api-to-set-several-variables","text":"@Component class SomeService ( private val runtimeService : RuntimeService , private val taskService : TaskService ) { fun setNewValuesForExecution ( executionId : String , rderId : String , orderApproved : Boolean ) { runtimeService . writer ( executionId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ) . update ( ORDER_TOTAL , { amount -> amount . add ( 10 ) }) } fun setNewValuesForTask ( taskId : String , orderId : String , orderApproved : Boolean ) { taskService . writer ( taskId ) . set ( ORDER_ID , orderId ) . set ( ORDER_APPROVED , orderApproved ) } fun start () { val variables = createProcessVariables () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) runtimeService . startProcessInstanceById ( \"myId\" , \"businessKey\" , variables ) } }","title":"Fluent API to set several variables"},{"location":"user-guide/examples-kotlin.html#fluent-api-to-read-several-variables","text":"@Component class SomeService ( private val runtimeService : RuntimeService , private val taskService : TaskService ) { fun readValuesFromExecution ( executionId : String ): String { val reader = CamundaBpmData . reader ( runtimeService , executionId ) val orderId = reader . get ( ORDER_ID ) val orderApproved = reader . get ( ORDER_APPROVED ) if ( orderApproved ) { // ... } return orderId } fun readValuesFromTask ( taskId : String ): String { val reader = CamundaBpmData . reader ( taskService , taskId ) val orderId = reader . get ( ORDER_ID ) val orderApproved = reader . get ( ORDER_APPROVED ) if ( orderApproved ) { // ... } return orderId } }","title":"Fluent API to read several variables"},{"location":"user-guide/examples-kotlin.html#anti-corruption-layer-wrap-variables-to-correlate","text":"@Component class SomeService { val MESSAGE_ACL = CamundaBpmDataMapper . identityReplace ( \"__transient\" , true ); fun correlate () { val variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . wrap ( variables )); } }","title":"Anti-Corruption-Layer: Wrap variables to correlate"},{"location":"user-guide/examples-kotlin.html#anti-corruption-layer-check-and-wrap-variables-to-correlate","text":"@Component class SomeService { val MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , true , VariablesGuard ( exists ( ORDER_ID )), IdentityVariableMapTransformer ); fun correlate () { val variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . checkAndWrap ( variables )); } }","title":"Anti-Corruption-Layer: Check and wrap variables to correlate"},{"location":"user-guide/examples-kotlin.html#define-guards-to-validate-variables-in-the-process","text":"@Configuration class VariableGuardConfiguration { companion object { const val LOAD_OPERATIONAL_FILE_GUARD = \"loadOperationalFileGuard\" ; } @Bean // assuming dependencys to implement javax.validation:validation-api are present fun validatorSupplier (): Supplier < Validator > = Supplier { Validation . buildDefaultValidatorFactory (). validator } @Bean ( LOAD_OPERATIONAL_FILE_GUARD ) fun loadOperationalFileGuard ( validatorSupplier : Supplier < Validator > ): ExecutionListener = DefaultGuardExecutionListener ( VariablesGuard ( listOf ( REQUIRED_VALUE . exists (), FUTURE_VALUE . notExists (), THE_ANSWER . hasValue ( 42 ), MY_DIRECTION . hasOneOfValues ( setOf ( \"left\" , \"up\" , \"down\" )), USER_EMAIL . isEmail (), DOCUMENT_ID . isUuid (), DOCUMENT_BODY . matches { return @matches true }, DOCUMENT_BODY . matches ( this :: validationMessageSupplier ) { return @matches true }, DOCUMENT_BODY . matchesRegexLocal ( Regex ( \"^Dude.*\" ), \"Starts with 'Dude'\" ), MY_DOCUMENT . isValidBean ( validatorSupplier ) ) ), true ) private fun validationMessageSupplier ( variableFactory : VariableFactory < String > , localLabel : String , option : Optional < String > ) = \"Expecting $ localLabel variable ' ${ variableFactory . name } ' to always match my document body matcher, but its value ' ${ option . get () } ' has not.\" } class MyDocument ( @field : Email val email : String )","title":"Define Guards to validate variables in the process"},{"location":"user-guide/examples-kotlin.html#example-project","text":"For more examples, please check out the Kotlin Example project, at GitHub .","title":"Example project"},{"location":"user-guide/examples-no-engine.html","text":"Use case # In seldom cases you may want to use the camunda-bpm-data library without Camunda BPM Engine. The most frequent case for this is if you provide a third-party library that is used with or without the engine. In particular, there is no way to use functionality relying on the Camunda engine without it, but there is some functionality working on simple Map<String, Object> or VariableMap (from a separate small library org.camunda.commons:camunda-commons-typed-values ) which is still usable WITHOUT having the entire Camunda BPM Engine on the class path. Limitations # Due to limitations provided by the JVM, usage of CamundaBpmData convenience methods is NOT POSSIBLE if the parts of the Java Camunda API is not on the classpath ( RuntimeService , TaskService , LockedExternalTask , ...). Default solution # The default solution for this problem would be to put the org.camunda.bpm:camunda-engine Camunda BPM Engine JAR on the classpath, but don't initialize the Camunda BPM Engine. Alternative solution # In order to make the JAR footprint lighter, we created a special artifact, which provides the Camunda BPM API only (API classes only but no implementation). This artifact includes ORIGINAL Camunda BPM classes of the API. In the same time, we started a discussion with Camunda Team to provide a dedicated API JAR of the engine. We will produce the Camunda BPM API for the upcoming releases. Instead of using the original engine JAR, you might want to put the following artifact on your classpath: <dependency> <groupId> io.holunda.camunda-api </groupId> <artifactId> camunda-bpm-engine-api </artifactId> <version> ${camunda.version} </version> </dependency> For more information about the Camunda BPM API, please check its GitHub project page: https://github.com/holunda-io/camunda-bpm-api/","title":"Usage without Camunda Platform"},{"location":"user-guide/examples-no-engine.html#use-case","text":"In seldom cases you may want to use the camunda-bpm-data library without Camunda BPM Engine. The most frequent case for this is if you provide a third-party library that is used with or without the engine. In particular, there is no way to use functionality relying on the Camunda engine without it, but there is some functionality working on simple Map<String, Object> or VariableMap (from a separate small library org.camunda.commons:camunda-commons-typed-values ) which is still usable WITHOUT having the entire Camunda BPM Engine on the class path.","title":"Use case"},{"location":"user-guide/examples-no-engine.html#limitations","text":"Due to limitations provided by the JVM, usage of CamundaBpmData convenience methods is NOT POSSIBLE if the parts of the Java Camunda API is not on the classpath ( RuntimeService , TaskService , LockedExternalTask , ...).","title":"Limitations"},{"location":"user-guide/examples-no-engine.html#default-solution","text":"The default solution for this problem would be to put the org.camunda.bpm:camunda-engine Camunda BPM Engine JAR on the classpath, but don't initialize the Camunda BPM Engine.","title":"Default solution"},{"location":"user-guide/examples-no-engine.html#alternative-solution","text":"In order to make the JAR footprint lighter, we created a special artifact, which provides the Camunda BPM API only (API classes only but no implementation). This artifact includes ORIGINAL Camunda BPM classes of the API. In the same time, we started a discussion with Camunda Team to provide a dedicated API JAR of the engine. We will produce the Camunda BPM API for the upcoming releases. Instead of using the original engine JAR, you might want to put the following artifact on your classpath: <dependency> <groupId> io.holunda.camunda-api </groupId> <artifactId> camunda-bpm-engine-api </artifactId> <version> ${camunda.version} </version> </dependency> For more information about the Camunda BPM API, please check its GitHub project page: https://github.com/holunda-io/camunda-bpm-api/","title":"Alternative solution"},{"location":"user-guide/features.html","text":"Process Variables The library provides a way to construct a generic adapter for every process variable. The adapter contains variable type. The adapter can be applied in any context ( RuntimeService , TaskService , CaseService , DelegateExecution , DelegateTask , DelegateCaseExecution , VariableMap , LockedExternalTask ). The adapter offers methods to read, write, update and remove variable values. The adapter works for all types supported by Camunda BPM. This includes primitive types, object and container types ( List<T> , Set<T> , Map<K , V> ). The adapter supports global / local variables. The adapter allows a default value or null in case a variable is not set. The adapter support transient variables. Fluent API helper are available in order to set, remove or update multiple variables in the same context ( VariableMapBuilder , VariableReader and GlobalVariableWriter ). Process Variable Guards Generic support for VariableGuard for evaluation of a list of VariableCondition s Condition to check if variable exists. Condition to check if variable doesn't exist Condition to check if variable has a predefined value. Condition to check if variable has one of predefined values. Condition to check if variable matches condition specified by a custom function. Condition to check if variable matches provided regular expression. Condition to check if variable is a valid email address. Condition to check if variable is a valid UUID. DefaultGuardTaskListener to construct variable conditions guards easily. DefaultGuardExecutionListener to construct variable conditions guards easily. Anti-Corruption-Layer Generic support for AntiCorruptionLayer for protection and influence of variable modification in signalling and message correlation. Helper methods for the client to wrap variables in a transient carrier. Execution listener to handle VariableGuard -based conditions and VariableMapTransformer -based modifications. Task listener to handle VariableGuard -based conditions and VariableMapTransformer -based modifications. Factory methods to create AntiCorruptionLayer with a VariableGuard (see CamundaBpmDataACL ) Factory methods to create AntiCorruptionLayer without a VariableGuard (see CamundaBpmDataMapper ) Testing variable access and mocking RuntimeService , TaskService and CaseService . Builder to create Mockito-based behaviour of RuntimeService accessing variables. Builder to create Mockito-based behaviour of TaskServiceService accessing variables. Builder to create Mockito-based behaviour of CaseServiceService accessing variables. Verifier to check correct access to variables in RuntimeService Verifier to check correct access to variables in TaskService Verifier to check correct access to variables in CaseService","title":"Features"},{"location":"user-guide/further-outlook.html","text":"Implement Contracts to be able to check guards automatically // We implemented all features we could imagine so far, if you are missing something, please // open an issue in https://github.com/holunda-io/camunda-bpm-data/issues[Github].","title":"Further Outlook"},{"location":"user-guide/motivation.html","text":"Typed access to process variables # Camunda BPM engine provide Java API to access the process variables. This consists of: RuntimeService methods TaskService methods Methods on DelegateExecution Methods on DelegateTask VariableMap All those methods requires the user of the API to know the variable type. Here is a usage example: ProcessInstance processInstance = ...; List < OrderPosition > orderPositions = ( List < OrderPosition > ) runtimeService . getVariable ( processInstance . id , \"orderPositions\" ); This leads to problems during refactoring and makes variable access more complicated than it is. This library addresses this issue and allows for more convenient type-safe process variable access. More details can be found in: Data in Process (Part 1) Data in Process (Part 2) Variable guards # Process automation often follows strict rules defined by the business. On the other hand, the process execution itself defines rules in terms of pre- and post-conditions on the process payload (stored as process variables in Camunda BPM). Rising complexity of the implemented processes makes the compliance to those rules challenging. In order to fulfill the conditions on process variables during the execution of business processes, a concept of VariableGuard is provided by the library. A guard consists of a set of VariableConditions and can be evaluated in all contexts, the variables are used in: DelegateTask , DelegateExecution , TaskService , RuntimeService , VariableMap . Here is an example of a task listener defining a VariablesGuard to test that the process variables ORDER_APPROVED and APPROVER_ID are set, which will throw a GuardViolationException if the condition is not met. import static io.holunda.camunda.bpm.data.guard.CamundaBpmDataGuards.exists ; @Component class MyGuardListener extends DefaultGuardTaskListener { public MyGuardListener () { super ( new VariablesGuard ( List . of ( exists ( ORDER_APPROVED ), exists ( APPROVER_ID )), true ); } } By default, all conditions of a VariablesGuard must be met in order to pass the validations. This behaviour can be explicitly defined by passing the reduceOperator = VariablesGuard.ALL when creating the VariablesGuard . The reduceOperator can take the following values: reduceOperator Semantics VariablesGuard.ALL All VariableCondition s must be met VariablesGuard.ONE_OF At least ONE VariableCondition must be met Anti-Corruption-Layer # If a process is signalled or hit by a correlated message, there is no way to check if the transported variables are set correctly. In addition, the variables are written directly to the execution of the correlated process instance. In case of a multi-instance event-base sub-process this will eventually overwrite the values of the main execution. To prevent all this, a feature called Anti-Corruption-Layer (ACL) is implemented. An ACL is there to protect the execution from bad modifications and influence the way, the modification is executed. For the protection, an ACL relies on a Variables Guards, defining conditions to be satisfied. For the influencing of modification, the VariableMapTransformer can be used. To use the ACL layer you will need to change the way you correlate messages (or signal the execution). Instead of supplying the variables directly to the correlate method of the RuntimeService , the client is wrapping all variables into a map hold by a single transient variable and correlate this variable with the process (we call this procedure variable wrapping). On the process side, an execution listener placed on the end of the catch event is responsible to extract the variable map from the transient variable, check it by passing through the VariablesGuard and finally pass over to the VariableMapTransformer to map from external to internal representation. Here is the code, required on the client side to correlate the message. @Component class SomeService { private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , // name of the transient variable for wrapping true , // if passes the guard, write to local scope new VariablesGuard ( exists ( ORDER_ID )), // guard defining condition on ORDER_ID IdentityVariableMapTransformer . INSTANCE // use 1:1 transformer // write the variables without modifications ); public void correlate () { VariableMap variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . checkAndWrap ( variables )); } } On the process side, the BPMN message catch event should have an End listener responsible for unwrapping the values. If the listener is implemented as a Spring Bean bounded via delegate expression ${messageAclListener} then the following code is responsible for providing such a listener: @Configuration class SomeConfiguration { private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , // name of the transient variable for wrapping true , // if passes the guard, write to local scope new VariablesGuard ( exists ( ORDER_ID )), // guard defining condition on ORDER_ID IdentityVariableMapTransformer . INSTANCE // use 1:1 transformer // write the variables without modifications ); @Bean ( \"messageAclListener\" ) public ExecutionListener messageAclListener () { return MY_ACL . getExecutionListener (); } } Such a setup will only allow to correlate messages, if the variables provided include a value for the ORDER_ID . It will write all variables provided ( ORDER_ID and ORDER_APPROVED ) into a local scope of the execution.","title":"Motivation"},{"location":"user-guide/motivation.html#typed-access-to-process-variables","text":"Camunda BPM engine provide Java API to access the process variables. This consists of: RuntimeService methods TaskService methods Methods on DelegateExecution Methods on DelegateTask VariableMap All those methods requires the user of the API to know the variable type. Here is a usage example: ProcessInstance processInstance = ...; List < OrderPosition > orderPositions = ( List < OrderPosition > ) runtimeService . getVariable ( processInstance . id , \"orderPositions\" ); This leads to problems during refactoring and makes variable access more complicated than it is. This library addresses this issue and allows for more convenient type-safe process variable access. More details can be found in: Data in Process (Part 1) Data in Process (Part 2)","title":"Typed access to process variables"},{"location":"user-guide/motivation.html#variable-guards","text":"Process automation often follows strict rules defined by the business. On the other hand, the process execution itself defines rules in terms of pre- and post-conditions on the process payload (stored as process variables in Camunda BPM). Rising complexity of the implemented processes makes the compliance to those rules challenging. In order to fulfill the conditions on process variables during the execution of business processes, a concept of VariableGuard is provided by the library. A guard consists of a set of VariableConditions and can be evaluated in all contexts, the variables are used in: DelegateTask , DelegateExecution , TaskService , RuntimeService , VariableMap . Here is an example of a task listener defining a VariablesGuard to test that the process variables ORDER_APPROVED and APPROVER_ID are set, which will throw a GuardViolationException if the condition is not met. import static io.holunda.camunda.bpm.data.guard.CamundaBpmDataGuards.exists ; @Component class MyGuardListener extends DefaultGuardTaskListener { public MyGuardListener () { super ( new VariablesGuard ( List . of ( exists ( ORDER_APPROVED ), exists ( APPROVER_ID )), true ); } } By default, all conditions of a VariablesGuard must be met in order to pass the validations. This behaviour can be explicitly defined by passing the reduceOperator = VariablesGuard.ALL when creating the VariablesGuard . The reduceOperator can take the following values: reduceOperator Semantics VariablesGuard.ALL All VariableCondition s must be met VariablesGuard.ONE_OF At least ONE VariableCondition must be met","title":"Variable guards"},{"location":"user-guide/motivation.html#anti-corruption-layer","text":"If a process is signalled or hit by a correlated message, there is no way to check if the transported variables are set correctly. In addition, the variables are written directly to the execution of the correlated process instance. In case of a multi-instance event-base sub-process this will eventually overwrite the values of the main execution. To prevent all this, a feature called Anti-Corruption-Layer (ACL) is implemented. An ACL is there to protect the execution from bad modifications and influence the way, the modification is executed. For the protection, an ACL relies on a Variables Guards, defining conditions to be satisfied. For the influencing of modification, the VariableMapTransformer can be used. To use the ACL layer you will need to change the way you correlate messages (or signal the execution). Instead of supplying the variables directly to the correlate method of the RuntimeService , the client is wrapping all variables into a map hold by a single transient variable and correlate this variable with the process (we call this procedure variable wrapping). On the process side, an execution listener placed on the end of the catch event is responsible to extract the variable map from the transient variable, check it by passing through the VariablesGuard and finally pass over to the VariableMapTransformer to map from external to internal representation. Here is the code, required on the client side to correlate the message. @Component class SomeService { private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , // name of the transient variable for wrapping true , // if passes the guard, write to local scope new VariablesGuard ( exists ( ORDER_ID )), // guard defining condition on ORDER_ID IdentityVariableMapTransformer . INSTANCE // use 1:1 transformer // write the variables without modifications ); public void correlate () { VariableMap variables = CamundaBpmData . builder () . set ( ORDER_ID , \"4711\" ) . set ( ORDER_APPROVED , false ) . build (); runtimeService . correlateMessage ( \"message_1\" , MESSAGE_ACL . checkAndWrap ( variables )); } } On the process side, the BPMN message catch event should have an End listener responsible for unwrapping the values. If the listener is implemented as a Spring Bean bounded via delegate expression ${messageAclListener} then the following code is responsible for providing such a listener: @Configuration class SomeConfiguration { private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL . guardTransformingReplace ( \"__transient\" , // name of the transient variable for wrapping true , // if passes the guard, write to local scope new VariablesGuard ( exists ( ORDER_ID )), // guard defining condition on ORDER_ID IdentityVariableMapTransformer . INSTANCE // use 1:1 transformer // write the variables without modifications ); @Bean ( \"messageAclListener\" ) public ExecutionListener messageAclListener () { return MY_ACL . getExecutionListener (); } } Such a setup will only allow to correlate messages, if the variables provided include a value for the ORDER_ID . It will write all variables provided ( ORDER_ID and ORDER_APPROVED ) into a local scope of the execution.","title":"Anti-Corruption-Layer"}]}